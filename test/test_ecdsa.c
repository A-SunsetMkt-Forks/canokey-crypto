#include <stdarg.h>
#include <stddef.h>
#include <setjmp.h>
#include <cmocka.h>

#include "ecdsa.h"

static void test_ecdsa_keygen(void **state) {
  (void) state;
  uint8_t priv_key[32], pub_key[64];
  uint8_t expected[] =
      {0x79, 0xBE, 0x66, 0x7E, 0xF9, 0xDC, 0xBB, 0xAC, 0x55, 0xA0, 0x62, 0x95, 0xCE, 0x87, 0x0B, 0x07, 0x02, 0x9B, 0xFC,
       0xDB, 0x2D, 0xCE, 0x28, 0xD9, 0x59, 0xF2, 0x81, 0x5B, 0x16, 0xF8, 0x17, 0x98, 0x48, 0x3A, 0xDA, 0x77, 0x26, 0xA3,
       0xC4, 0x65, 0x5D, 0xA4, 0xFB, 0xFC, 0x0E, 0x11, 0x08, 0xA8, 0xFD, 0x17, 0xB4, 0x48, 0xA6, 0x85, 0x54, 0x19, 0x9C,
       0x47, 0xD0, 0x8F, 0xFB, 0x10, 0xD4, 0xB8};
  ecdsa_generate(ECDSA_SECP256K1, priv_key, pub_key);
  for (int i = 0; i != 31; ++i) {
    assert_int_equal(priv_key[i], 0);
  }
  assert_int_equal(priv_key[31], 1);
  for (int i = 0; i != 32; ++i) {
    assert_int_equal(pub_key[i], expected[i]);
  }
}

static void test_ecdsa_sign(void **state) {
  (void) state;
  uint8_t priv_key[32], pub_key[64], sig[64];
  uint8_t digest[32] =
      {0x98, 0x34, 0x87, 0x6d, 0xcf, 0xb0, 0x5c, 0xb1, 0x67, 0xa5, 0xc2, 0x49, 0x53, 0xeb, 0xa5, 0x8c, 0x4a, 0xc8, 0x9b,
       0x1a, 0xdf, 0x57, 0xf2, 0x8f, 0x2f, 0x9d, 0x09, 0xaf, 0x10, 0x7e, 0xe8, 0xf0};
  uint8_t expected[] =
      {0x79, 0xBE, 0x66, 0x7E, 0xF9, 0xDC, 0xBB, 0xAC, 0x55, 0xA0, 0x62, 0x95, 0xCE, 0x87, 0x0B, 0x07, 0x02, 0x9B, 0xFC,
       0xDB, 0x2D, 0xCE, 0x28, 0xD9, 0x59, 0xF2, 0x81, 0x5B, 0x16, 0xF8, 0x17, 0x98, 0x11, 0xF2, 0xED, 0xEC, 0xC9, 0x8D,
       0x18, 0x5D, 0xBD, 0x46, 0x24, 0xDF, 0x22, 0x72, 0xB0, 0x94, 0x92, 0xB5, 0xBB, 0x0F, 0x5D, 0xDD, 0x7B, 0x2C, 0xC9,
       0xBD, 0x2C, 0x7D, 0x57, 0x40, 0xBF, 0x47};
  ecdsa_generate(ECDSA_SECP256K1, priv_key, pub_key);
  ecdsa_sign(ECDSA_SECP256K1, priv_key, digest, sig);
  for (int i = 0; i != 32; ++i) {
    assert_int_equal(sig[i], expected[i]);
  }
}

static void test_ecdsa_verify(void **state) {
  (void) state;
  uint8_t priv_key[32], pub_key[64];
  uint8_t digest[32] =
      {0x98, 0x34, 0x87, 0x6d, 0xcf, 0xb0, 0x5c, 0xb1, 0x67, 0xa5, 0xc2, 0x49, 0x53, 0xeb, 0xa5, 0x8c, 0x4a, 0xc8, 0x9b,
       0x1a, 0xdf, 0x57, 0xf2, 0x8f, 0x2f, 0x9d, 0x09, 0xaf, 0x10, 0x7e, 0xe8, 0xf0};
  uint8_t sig[64] =
      {0x79, 0xBE, 0x66, 0x7E, 0xF9, 0xDC, 0xBB, 0xAC, 0x55, 0xA0, 0x62, 0x95, 0xCE, 0x87, 0x0B, 0x07, 0x02, 0x9B, 0xFC,
       0xDB, 0x2D, 0xCE, 0x28, 0xD9, 0x59, 0xF2, 0x81, 0x5B, 0x16, 0xF8, 0x17, 0x98, 0x11, 0xF2, 0xED, 0xEC, 0xC9, 0x8D,
       0x18, 0x5D, 0xBD, 0x46, 0x24, 0xDF, 0x22, 0x72, 0xB0, 0x94, 0x92, 0xB5, 0xBB, 0x0F, 0x5D, 0xDD, 0x7B, 0x2C, 0xC9,
       0xBD, 0x2C, 0x7D, 0x57, 0x40, 0xBF, 0x47};
  ecdsa_generate(ECDSA_SECP256K1, priv_key, pub_key);
  assert_int_equal(ecdsa_verify(ECDSA_SECP256K1, pub_key, sig, digest), 0);
}

int main() {
  const struct CMUnitTest tests[] = {
      cmocka_unit_test(test_ecdsa_keygen),
      cmocka_unit_test(test_ecdsa_sign),
      cmocka_unit_test(test_ecdsa_verify),
  };

  return cmocka_run_group_tests(tests, NULL, NULL);
}
